# Экзаменационный билет №1 

## Задание

### Вопрос 1 

Структурный состав и принцип работы подсистемы ввода-вывода в Unix (Обработчик прерываний, драйвер устройств, независимый от аппаратуры код ОС, пользовательское приложение).

### Вопрос 2 

Опишите основные методы управления памятью. Страницы, сегменты, виртуальная адресация.

### Практическое задание

Произвести перманентную модификацию системы, обеспечив вызов комнадного интерпретатора посредством передачи в консоль текстовой строки «1337».

## Ответы

### Ответ 1 

Подсистема ввода-вывода построена как **многослойная архитектура** для изоляции сложности и обеспечения переносимости. Её можно разделить на четыре ключевых компонента, расположенных "сверху вниз" по уровню абстракции:

1.  **Пользовательское приложение:** Это программы (`cat`, `vim`, ваш скрипт), которые используют ввод-вывод. Они видят только абстракцию в виде **файлов** или **потоков данных** и работают через стандартные системные вызовы (`read`, `write`, `open`).

2.  **Независимый от устройств код ОС (файловая подсистема):** Это общая инфраструктура ядра. Её задача — предоставить приложениям унифицированный интерфейс к любому устройству. Она управляет буферами в оперативной памяти, кэшированием, правами доступа, блокировками и очередями запросов. Ключевая концепция здесь — **"Всё есть файл"**. Устройство представлено как специальный файл (например, `/dev/sda`). Этот слой знает *что* нужно сделать, но не *как* это сделать на конкретном железе.

3.  **Драйвер устройства (модуль ядра):** Это "переводчик", привязанный к конкретной модели аппаратуры (диска, сетевой карты). Его код делится на две логические части:
    *   **Верхняя половина:** Интерфейсная часть, которая общается с независимым кодом ОС по строго определённому контракту. Получает от ядра абстрактный запрос.
    *   **Нижняя половина (обработчик прерываний):** Аппаратно-зависимая часть, которая напрямую "шевелит" регистры контроллера устройства, отправляя ему команды. Также она обрабатывает сигналы от устройства.

4.  **Обработчик прерываний (часть драйвера):** Не является полностью отдельным модулем — это асинхронная функция внутри драйвера. Она активируется аппаратным прерыванием от контроллера устройства, когда оно завершило операцию (данные готовы, диск нашел сектор). Его цель — максимально быстро обслужить железо: считать сырые данные из регистров устройства в буфер ядра и сообщить системе, что операция завершена.

Работа подсистемы — это **цикл запроса и ответа**, в котором участвуют все её компоненты.

**Фаза 1: Запрос (путь "вниз", синхронный)**

1.  **Приложение** делает системный вызов, например, `read(fd, buffer, size)`. Вызов переключает процесс в режим ядра.
2.  **Независимый код ОС** принимает вызов. Он определяет, что файловый дескриптор `fd` связан с устройством (например, с диском). Код выполняет проверки прав, находит нужный буфер в кэше, и, если данных там нет, формирует абстрактный запрос "прочитать блок N". Затем он находит драйвер, отвечающий за это устройство, и вызывает его "верхнюю половину".
3.  **Драйвер (верхняя половина)** получает абстрактный запрос и переводит его на язык железа: вычисляет физические адреса (цилиндр/головку/сектор для диска), помещает эти команды в очередь контроллера устройства и "запускает" аппаратуру. После этого драйвер обычно переводит запросивший процесс в состояние **сна ("sleep")**, чтобы не тратить процессорное время на ожидание.

**Фаза 2: Ожидание (бездействие CPU)**

Процессор **не ждёт** медленное устройство. Он освобождается и выполняет другие процессы. Устройство (например, диск) механически ищет нужные данные.

**Фаза 3: Ответ (путь "вверх", асинхронный)**

1.  Как только устройство готово, его контроллер посылает в CPU **аппаратное прерывание**.
2.  Процессор приостанавливает текущую работу и запускает **обработчик прерываний (нижнюю половину драйвера)**. Этот обработчик делает минимум работы: считывает сырые данные из портов устройства в заранее подготовленный буфер в памяти, "отмечает" операцию как завершенную и **пробуждает ("wakeup")** тот самый процесс, который спал в ожидании.
3.  Проснувшийся процесс возвращается в **независимый код ОС**. Тот проверяет статус операции, выполняет необходимую постобработку данных (если нужно), копирует их из системного буфера в пространство пользователя.
4.  Управление возвращается в **пользовательское приложение**. Системный вызов `read()` завершается, и программа получает запрошенные данные, как будто они просто лежали в файле.

**Главный принцип**, реализуемый этой структурой — **абстракция через интерфейсы и разделение ответственности**. Приложение ничего не знает о железе, ядро — о конкретных моделях устройств, а драйвер — о логике файловых систем или сетевых протоколов. Это позволяет легко добавлять новые устройства, не меняя ядро и приложения. А механизм прерываний и ожидания обеспечивает эффективное использование процессорного времени в условиях, когда устройства работают на порядки медленнее CPU.

### Ответ 2 

**Линейная память** — это как прямая линия от 0 до конца ОЗУ. Программа видит все железо напрямую. Проблема: если запустить две программы, они будут мешать друг другу, записывая данные поверх чужих.

**Сегменты** — это попытка навести порядок, разделив память не физически, а логически. Представьте книгу с разными главами: код, данные, стек — каждая глава это сегмент. У каждой главы свой размер и правила: например, в главе "код" можно только читать, а в "данные" — и читать, и писать. Адрес теперь состоит из двух частей: "выбери главу" и "перейди на абзац внутри нее". Это создает защиту и структуру, но приводит к проблеме: если главам нужны разные размеры, между ними остаются неиспользуемые дыры в памяти (внешняя фрагментация). Управлять таким хозяйством сложно.

**Страницы** — это отказ от логических глав в пользу унификации. Память нарезается на фиксированные "листы" одного размера (обычно 4 КБ). Программа по-прежнему видит непрерывную линейную виртуальную память, но физически ее "листы" могут быть разбросаны где угодно в ОЗУ или даже лежать на диске. Главное преимущество — гибкость: любой свободный "лист" подходит для любой задачи, дыр не остается. Появляется магия **виртуальной памяти**: системе не важно, помещается ли вся программа в ОЗУ целиком, потому что неиспользуемые страницы можно временно сбросить на диск. Это основа современной многозадачности.

**Ключевое отличие:**
*   **Сегмент** — это логическая единица программы (например, весь код). Переменного размера.
*   **Страница** — это физическая единица размещения данных в памяти. Фиксированного размера.
*   Страничная организация победила, потому что она **механистична** и изящно решает проблему фрагментации и переполнения ОЗУ, в то время как сегментация **семантична**, но громоздка в управлении.

**Устройство виртуальной памяти на железе: механизм трансляции**

Виртуальная память — это не абстракция ОС, а **аппаратная технология**. Ее двигатель — **MMU (Memory Management Unit)**, встроенный в процессор.

Вот как это работает на физическом уровне:

1.  Когда программа обращается к адресу (например, `0x401000`), это **виртуальный адрес**. Он не имеет прямого отношения к физической шине памяти. MMU должен перевести его в реальный **физический адрес**.

2.  В основе лежит **таблица страниц** — иерархическая структура в памяти, которую подготовило ядро ОС для каждого процесса. Корень этой таблицы (указатель на ее начало) хранится в специальном регистре процессора — **CR3**.

3.  **Трансляция адреса — это "поиск по индексам"**.
    *   Виртуальный адрес битами разбивается на несколько полей-индексов (например, для 4-уровневой таблицы: индекс1, индекс2, индекс3, индекс4 и смещение).
    *   MMU берет индекс1 и CR3, находит первую таблицу, читает из нее запись (физический адрес следующей таблицы).
    *   Берет индекс2 и этот адрес, находит вторую таблицу, и так далее, спускаясь по иерархии.
    *   В финальной записи (**PTE — Page Table Entry**) хранится **физический адрес начала страницы** в ОЗУ и **биты управления**: присутствует ли страница в ОЗУ, доступна ли для записи, обращались ли к ней, была ли изменена.

4.  MMU прибавляет к физическому адресу страницы **смещение** из виртуального адреса и получает итоговый физический адрес, который уходит на шину памяти. Вся эта процедура выполняется аппаратно и очень быстро, для ускорения используется **TLB (Translation Lookaside Buffer)** — кэш внутри процессора для уже переведенных адресов.

**Магия и защита:**
*   Если в PTE бит "присутствует" сброшен, MMU генерирует **прерывание — page fault**. Это сигнал ядру: "страницы нет в ОЗУ!". Ядро может загрузить ее с диска (из swap или файла), после чего перезапустит операцию.
*   Если программа пытается записать в страницу с битом "только для чтения" или обратиться к странице ядра из пользовательского режима, MMU генерирует **исключение защиты**, и процесс получает сигнал SIGSEGV (Segmentation Fault).

**Итог сути:** Виртуальная память на железе — это **аппаратный транслятор (MMU)**, который, используя **персональные "словари перевода" (таблицы страниц)**, превращает адреса программ в реальные адреса ОЗУ, одновременно проверяя права доступа и обеспечивая магию подкачки.
