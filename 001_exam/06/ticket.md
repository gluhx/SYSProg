# Экзаменационный билет №6 

## Задание

### Вопрос 1 

Ввод-вывод с отображением на память.

### Вопрос 2 

Разделы диска, загрузка ОС.

### Практическое задание

Произвести перманентную модификацию системы, обеспечивающую вывод приглашения к выбору ядра загрузчиком системы. Прокомментировать содержимое задействованных файлов.

## Ответы

### Ответ 1 

Это архитектурный подход, при котором **устройства ввода-вывода (периферия) отображаются не в отдельное адресное пространство портов ввода-вывода, а прямо в общее физическое адресное пространство оперативной памяти**.

Основной принцип (кратко)

**Устройства представляются не как набор специальных портов, к которым нужно обращаться отдельными командами (вроде `IN`/`OUT` в x86), а как обычные ячейки памяти с конкретными адресами.** Чтение и запись по этим "магическим" адресам на самом деле обращается не к ОЗУ, а к регистрам устройства.

Детальный принцип работы

1. Адресное пространство процессора
*   В системах с MMIO единое физическое адресное пространство делится на две части:
    *   **Диапазон для реальной оперативной памяти** (например, адреса `0x00000000` — `0x3FFFFFFF`).
    *   **Диапазон для MMIO-регистров устройств** (например, адреса `0x40000000` — `0xFFFFFFFF`). Этот диапазон "дырявый" — в нем адресуются отдельные устройства.

2. Как процессор обращается к устройству
1.  **Программа (драйвер)** выполняет обычную инструкцию работы с памятью, например:
    *   Загрузку регистра: `mov eax, [0xFEC00000]`
    *   Запись в память: `mov [0xFEC00000], eax`
2.  **Процессор** выставляет физический адрес (например, `0xFEC00000`) на шину адреса и сигнал чтения/записи.
3.  **Контроллер памяти (Memory Controller)** или **мост ввода-вывода** анализирует этот адрес.
4.  **Маршрутизация:** Поскольку адрес `0xFEC00000` находится в зарезервированном MMIO-диапазоне (а не в диапазоне ОЗУ), запрос **не направляется к чипам оперативной памяти**. Вместо этого он перенаправляется на **шину ввода-вывода** (например, PCIe).
5.  **Выбор устройства:** Каждое устройство на шине настроено (обычно через BIOS/UEFI или операционную систему) на отклик на определенный диапазон адресов. Устройство, для которого адрес `0xFEC00000` попадает в его назначенный диапазон, "отзывается" на запрос.
6.  **Доступ к регистру:** Запись или чтение происходит в конкретный **регистр устройства**, соответствующий смещению внутри его выделенного диапазона. Этот регистр может быть управляющим (command), статусным (status) или буфером данных (data).

3. Роль операционной системы и драйвера
*   **Резервирование:** При старте системы (BIOS/UEFI, а затем ядро ОС) составляется карта адресного пространства: определяется, какие диапазоны адресов заняты ОЗУ, а какие — устройствами MMIO (это информация из ACPI-таблиц).
*   **Защита:** Ядро ОС запрещает непривилегированным пользовательским программам прямой доступ к MMIO-диапазонам. Это предотвращает крах системы.
*   **Драйвер:** Чтобы работать с устройством, драйвер в ядре:
    1.  **Запрашивает у ядра** отображение физического MMIO-диапазона устройства в **виртуальное адресное пространство ядра**.
    2.  Получает **указатель** (например, `void *regs`) на этот отображенный диапазон в своей памяти.
    3.  Работает с устройством, просто читая и записывая данные по этому указателю, как с обычным массивом в памяти.
        ```c
        // Упрощенный псевдокод драйвера
        uint32_t *device_control_register = (uint32_t*)mmio_base_address;
        *device_control_register = 0x1; // Записать команду "ВКЛ" в регистр устройства
        status = *(device_control_register + 1); // Прочитать регистр статуса
        ```

Ключевые особенности и сравнение с Port-Mapped I/O (PMIO)

| Аспект | Memory-Mapped I/O (MMIO) | Port-Mapped I/O (PMIO) |
| :--- | :--- | :--- |
| **Адресное пространство** | Единое с памятью | Отдельное I/O-пространство (небольшое, 64К портов в x86) |
| **Инструкции процессора** | Обычные инструкции работы с памятью (`mov`, `ldr`, `str`). Могут кэшироваться, могут переупорядочиваться. | Специальные инструкции ввода-вывода (`in`, `out` в x86). Обычно не кэшируются и выполняются строго по порядку. |
| **Адресация** | Прямой доступ по адресу. Удобно для структур данных. | Косвенная: номер порта в регистре. Удобно для маленьких устройств. |
| **Производительность** | Потенциально выше, т.к. использует все оптимизации работы с памятью. Но требует управления кэшированием. | Предсказуемая, но часто медленнее из-за специальных команд и отсутствия оптимизаций. |
| **Сложность оборудования** | Требует более сложного декодирования адресов на шине. | Проще в реализации для простых устройств. |
| **Типичное применение** | **Доминирующий метод** для современных высокопроизводительных устройств: видеокарты, контроллеры дисков, сетевые карты (PCI/PCIe). | Используется для простых, устаревших или низкоуровневых устройств: контроллер прерываний (PIC/APIC), часы реального времени (RTC), последовательный порт (COM). |

Проблемы и их решения в MMIO

1.  **Проблема кэширования:** Процессор может кэшировать обращение к памяти. Если драйвер читает регистр статуса устройства, который меняется самотоятельно, то из кэша процессор может получить устаревшее значение.
    *   **Решение:** Помечать MMIO-области как **некэшируемые (uncacheable)** на уровне таблиц страниц или атрибутов шины. Это гарантирует, что каждое обращение уйдет на шину к устройству.

2.  **Проблема переупорядочивания операций:** Процессор или контроллер памяти может переставить порядок операций записи в память для оптимизации. Но для устройства **последовательность обращений к регистрам часто критически важна** (например, сначала записать данные в буфер, затем — команду в управляющий регистр).
    *   **Решение:** Использовать **барьеры памяти (memory barriers)**. Это специальные инструкции или атрибуты, которые заставляют процессор завершить все предыдущие обращения к памяти до того, как начнутся следующие.
    *   Пример в коде драйвера:
        ```c
        *data_buffer_register = my_data; // 1. Записали данные
        wmb(); // Write Memory Barrier: гарантия, что запись (1) завершилась
        *command_register = START_CMD; // 2. Только теперь даем команду
        ```

Вывод и аналогия

**Принцип работы MMIO** можно сравнить с **почтовыми ящиками в большом доме (адресном пространстве).**
*   Ящики с адресами 1-100 — это **квартиры (оперативная память)**, куда кладут письма для жильцов.
*   Ящики с адресами 101-150 — это **служебные ящики (MMIO-регистры)**, которые физически ведут не в квартиры, а к системам дома: ящик 101 — звонок в консьержу, ящик 102 — управление лифтом и т.д.
*   Положить записку в ящик 102 — это не положить её в память, а **нажать кнопку вызова лифта**. Это и есть обращение к устройству через адрес в памяти.

Таким образом, **MMIO** — это элегантный и мощный механизм, стирающий границу между обращением к памяти и управлением оборудованием, что позволяет использовать весь арсенал процессора для эффективной работы с периферией.

## Ответ 2 

**Раздел** — это логический "отрезок" физического диска. Таблица разделов (GPT или старая MBR) хранит карту этих отрезков.

Ключевые разделы в современной системе:

*   **ESP (EFI System Partition):** Маленький раздел (100-500 МБ) в формате **FAT32**. Критически важен для компьютеров с UEFI. В нём живут загрузчики ОС в виде файлов с расширением `.efi`. Без него UEFI не поймёт, как начать загрузку.

*   **Корневой раздел ( `/` ):** Здесь находится вся система Linux — ядро, системные библиотеки, программы. Форматируется в **ext4** (чаще всего), btrfs или xfs. Без него система не существует.

*   **Swap:** Раздел подкачки. Служит "продолжением" оперативной памяти (RAM) на диске. Имеет собственную файловую систему (swap). Используется, когда RAM переполнена, или для гибернации.

*   **Домашний раздел ( `/home` ):** Хранит данные пользователей — документы, настройки, загрузки. Форматируется обычно в **ext4**. Главное преимущество: при переустановке системы его можно сохранить, отформатировав только корневой раздел.

Как устанавливается ОС (кратко)

1.  Вы загружаетесь с установочной флешки.
2.  Инсталлятор предлагает разметить диск. Можно доверить это автоматике или сделать вручную.
3.  В ручном режиме вы:
    *   Создаёте новую таблицу разделов (обычно **GPT**).
    *   Создаёте **ESP** (FAT32, 500 МБ).
    *   Создаёте **корневой раздел** (ext4, точка монтирования `/`, например 50 ГБ).
    *   (Опционально) создаёте **swap** и **/home**.
4.  Инсталлятор форматирует разделы и копирует файлы системы в корневой раздел. Затем он устанавливает загрузчик (например, GRUB) в **ESP**, чтобы UEFI знала, где его искать.
5.  После перезагрузки начинается процесс загрузки.

Процесс загрузки (цепочка)

Это чёткая последовательность, где каждый следующий шаг запускается предыдущим.

1.  **UEFI/BIOS:** После включения компьютера прошивка материнской платы инициализирует железо. **UEFI** ищет **ESP**, находит в нём файл загрузчика (например, `grubx64.efi`) и запускает его.

2.  **Загрузчик (GRUB):** Его главная задача — найти и загрузить ядро операционной системы. GRUB читает конфигурацию, показывает меню выбора (если несколько систем или ядер) и загружает в память выбранное **ядро Linux** и специальный образ — **initramfs**.

3.  **Ядро и initramfs:** Ядро распаковывается в оперативной памяти. **Initramfs** — это временная корневая файловая система в RAM. Он содержит минимальный набор драйверов, необходимых, чтобы смонтировать **настоящий корневой раздел** (`/`), особенно если он зашифрован или находится на RAID.

4.  **Systemd и пользовательское пространство:** После монтирования корневого раздела управление передаётся первому процессу — **systemd**. Он запускает все остальные сервисы: монтирует `/home`, поднимает сеть, запускает графический сервер и, наконец, дисплейный менеджер для входа в систему.

**Итог:** Разделы — это организованные "ящики" на диске для разных целей, а загрузка — это многоступенчатый процесс передачи управления от простого кода прошивки к сложной операционной системе.
