# Экзаменационный билет №3 

## Задание

### Вопрос 1 

Понятие канала, вилы каналов.

### Вопрос 2 

Назовите основные методы загрузки программ.

### Практическое задание

Разработать программу на языке C, обрабатывающую файлы по заданному пути файловой системы посредством технологии Zstandard.

## Ответы

### Ответ 1 

Канал — это механизм межпроцессного взаимодействия (IPC - Inter-Process Communication), который позволяет передавать данные от одного процесса к другому. Это однонаправленный поток байтов, где один процесс пишет, а другой читает.

Ключевые характеристики:
- Данные читаются в порядке записи (FIFO - First In, First Out)
- Канал существует только пока есть процессы, использующие его
- Имеет ограниченный размер буфера (обычно 64 КБ в Linux)
- Операции чтения/записи блокируются при пустом/полном буфере

Виды каналов в Linux:

1. Анонимные каналы (Unnamed Pipes, `|`) - создаются с помощью системного вызова `pipe()` или оператора `|` в shell.

```bash
# Классический пример
ls -la | grep ".txt" | wc -l
# Вывод ls передается на вход grep, результат grep - на вход wc
```

Особенности:
- Существуют только между родственными процессами (родитель-потомок)
- Уничтожаются при завершении всех процессов
- Не имеют имени в файловой системе

2. Именованные каналы (Named Pipes, FIFO) - cоздаются с помощью `mkfifo()` и существуют как специальный файл в файловой системе.

```bash
# Создание FIFO
mkfifo mypipe

# Запись в канал (блокируется пока нет читателя)
echo "Hello" > mypipe &

# Чтение из канала
cat < mypipe
```

Особенности:
- Существуют независимо от процессов
- Видимы в файловой системе (`ls -l` покажет тип `p`)
- Могут использоваться неродственными процессами
- Удаляются командой `unlink()` или `rm`

**Ограничения и особенности**
- Размер буфера : можно узнать через `fcntl(fd, F_GETPIPE_SZ)`
- Атомарность записи: запись до PIPE_BUF (4096 байт) атомарна
- Сигнал SIGPIPE: генерируется при записи в канал без читателей

В ядре Linux каналы реализованы через:
- `struct pipe_inode_info` - содержит буферы и состояние
- Кольцевой буфер (circular buffer)
- Очередь ожидания (wait queue) для блокировки процессов

Важно: Современные версии Linux используют pipe buffer размером 16 страниц (обычно 64 КБ), но это можно изменить через `/proc/sys/fs/pipe-max-size`.

Каналы — фундаментальный механизм Unix-подобных систем, лежащий в основе философии "делай одну вещь и делай ее хорошо", позволяя комбинировать простые программы в сложные конвейеры обработки данных.

### Ответ 2 

**1. ELF-файл (например, `/bin/ls`)**
**Назначение файла**: Основной исполняемый файл. Хранит код программы, данные и инструкции ядру, как его загрузить.
**Как работает**: Ядро видит "магию" `0x7f 'E' 'L' 'F'` → читает **заголовки программы (Program Headers)** → загружает сегменты кода и данных в память → если файл **динамический**, в заголовке указан путь к **интерпретатору** (линкеру). Управление передается ему, а не напрямую программе.

**Ключевой подфайл**: **Секция `.dynamic`** внутри ELF. Это "шпаргалка" для линкера со списком необходимых библиотек (`DT_NEEDED`: `libc.so.6`).

**2. Динамический линкер (`/lib64/ld-linux-x86-64.so.2`)**
**Назначение файла**: **Менеджер зависимостей в userspace**. Его задача — найти и подключить к программе все недостающие части (общие библиотеки).
**Как работает**: 1) Получает управление от ядра. 2) Читает `.dynamic` основной программы. 3) Находит файлы `.so` (например, `libc.so.6`). 4) Выполняет **релокацию** — подставляет реальные адреса функций из библиотек в код программы. 5) Передает управление на `main()` программы.

**3. Общая библиотека (`.so`, например, `libc.so.6`)**
**Назначение файла**: **Разделяемый код**. Хранит функции, используемые многими программами (например, `printf()`, `open()`). Не копируется в каждую программу, а подгружается в память один раз и используется всеми.
**Как работает**: Линкер находит её на диске, отображает в память процесса и "связывает" вызовы из программы с адресами функций в этой библиотеке.

**4. Скрипт с шебангом (`#!/bin/bash`)**
**Назначение файла**: **Инструкция для ядра**. Первые байты `#!` — это не комментарий, а команда ядру: "не исполняй меня сам, отдай на выполнение этому интерпретатору".
**Как работает**: Ядро читает строку до `\n` → запускает указанный интерпретатор (например, `/bin/bash`) как обычный ELF-файл → передаёт ему путь к скрипту в качестве аргумента. Дальше работает интерпретатор.

**5. Файл-правило `binfmt_misc` (в `/proc/sys/fs/binfmt_misc/`)**
**Назначение файла**: **Расширитель возможностей ядра**. Позволяет научить ядро запускать файлы нестандартных форматов (`.jar`, `.py` без шебанга, `.exe`).
**Как работает**: Администратор создаёт в этой виртуальной папке файл-правило. В нём указано: "если файл начинается с байтов `\xca\xfe\xba\xbe` (Java) или имеет расширение `.jar`, то выполни команду `/usr/bin/java %s`". Ядро делает подстановку автоматически.

**6. Анонимный файловый дескриптор (`memfd`)**
**Назначение файла**: **Исполняемый файл, которого нет на диске**. Виртуальный контейнер в оперативной памяти для кода программы.
**Как работает**: Программа создаёт `memfd` системным вызовом → записывает в него готовый ELF-образ (например, скачанный из сети) → вызывает `fexecve()` для этого дескриптора. Ядро исполняет код из памяти, как если бы он был считан с диска. **Назначение**: безопасность (код не остаётся на диске) и атомарность (код нельзя подменить в момент между чтением и выполнением).

Отличные вопросы! Разберём по порядку.

**Что такое программные заголовки (Program Headers) в ELF?**
Это **инструкция для ядра или загрузчика** о том, **какие части файла нужно загрузить в оперативную память** и с какими правами (читать/писать/исполнять).

Если представить ELF-файл как книгу:
*   **Заголовок ELF (ELF Header)** — это **оглавление книги**. Он говорит: "Глава 1 (секция `.text`) начинается на странице 50, Глава 2 (секция `.data`) — на странице 100". Он описывает *структуру файла на диске*.
*   **Программные заголовки (Program Headers)** — это **инструкция для упаковщика**. Они говорят: "Чтобы книга работала, возьми Главу 1 и Главу 3, положи их в ящик памяти под номером `0x8048000`, дай права `RX`. Главу 2 положи в ящик `0x8060000` с правами `RW`". Они описывают *сегменты (segments) в памяти*.

**Главное**: Один **сегмент в памяти (segment)** может состоять из нескольких **секций файла (section)**. Ядру важны именно *сегменты*, потому что оно работает с памятью.

**Какие бывают основные типы программных заголовков?**
Вот ключевые типы (полный список можно найти в `man 5 elf`):

| Тип (PT_) | Назначение и что содержит | Права (R/W/X) |
| :--- | :--- | :--- |
| **`PT_LOAD`** **(САМЫЙ ВАЖНЫЙ)** | Указывает **загружаемый сегмент**. Таких заголовков обычно 2: один для кода (`.text`, `.rodata`), другой для данных (`.data`, `.bss`). Без него сегмент не попадёт в память. | `R+X` (код) или `R+W` (данные) |
| **`PT_DYNAMIC`** | Содержит данные для **динамического линкера**. Указывает на секцию **`.dynamic`** — "шпаргалку" с зависимостями. | `R` |
| **`PT_INTERP`** | Содержит **путь к интерпретатору** — динамическому линкеру (`/lib64/ld-linux-x86-64.so.2`). Если его нет, файл статический. | `R` |
| **`PT_PHDR`** | Указывает на **сам массив программных заголовков** в памяти. Нужен для отладки и продвинутой загрузки. | `R` |
| **`PT_NOTE`** | Служебная информация для системы (версия ABI, заметки компилятора). | `R` |
| **`PT_GNU_STACK`** | Флаг, определяющий, **должен ли стек быть исполняемым**. Ключевая мера безопасности (NX-bit). | (флаг, не сегмент) |

ELF-файл — это просто **последовательность байтов на носителе**.

**Краткая схема работы**
1.  **Диск**: Файл `/bin/ls` (последовательность байтов с ELF-заголовком и программными заголовками).
2.  **Загрузка**: Ядро читает `PT_LOAD` заголовки → создаёт в памяти сегменты → отображает в них части файла.
3.  **Выполнение**: Процесс работает в памяти, обращаясь к своему коду и данным через виртуальные адреса (`VirtAddr` из заголовков).

Итог: **Программные заголовки — это "путевой лист" для ядра**, а **ELF-файл физически лежит на диске как любой другой файл**, но с особым форматом, который понимает ОС.
