# Экзаменационный билет №1 

## Задание

### Вопрос 1 

Понятие сигналов, обработка сигналов

### Вопрос 2 

Назовите основные классы операционных систем. Приведите перечень основной функциональности операционных систем.

### Практическое задание

Разработать shell-скрипт, реализующий запись произвольной строки текстовых данных в активную консоль любого смежного пользователя текущей машины.

## Ответы

### Ответ 1 

Сигнал - асинхронное програмное прерывание, доставляемое процессу ядром, которое приводит к принудительному изменению потока управления процессом. Основной способ взаимодействия между процессами.

Когда сигнал послан процессу, операционная система прерывает выполнение процесса, при этом, если процесс установил собственный обработчик сигнала, операционная система запускает этот обработчик, передав ему информацию о сигнале, если процесс не установил обработчик, то выполняется обработчик по умолчани.

Чтобы отправить сигнал процессу нужно использовать утилиту kill, в которой сигнал можно задать как по номеру, так и по названию.

Список всех сигналов(может быть или 32, или 64, или 128):
 1)SIGHUP	 2) SIGINT	 3) SIGQUIT	 4) SIGILL	 5) SIGTRAP
 6) SIGABRT	 7) SIGBUS	 8) SIGFPE	 9) SIGKILL	10) SIGUSR1
11) SIGSEGV	12) SIGUSR2	13) SIGPIPE	14) SIGALRM	15) SIGTERM
16) SIGSTKFLT	17) SIGCHLD	18) SIGCONT	19) SIGSTOP	20) SIGTSTP
21) SIGTTIN	22) SIGTTOU	23) SIGURG	24) SIGXCPU	25) SIGXFSZ
26) SIGVTALRM	27) SIGPROF	28) SIGWINCH	29) SIGIO	30) SIGPWR
31) SIGSYS	34) SIGRTMIN	35) SIGRTMIN+1	36) SIGRTMIN+2	37) SIGRTMIN+3
38) SIGRTMIN+4	39) SIGRTMIN+5	40) SIGRTMIN+6	41) SIGRTMIN+7	42) SIGRTMIN+8
43) SIGRTMIN+9	44) SIGRTMIN+10	45) SIGRTMIN+11	46) SIGRTMIN+12	47) SIGRTMIN+13
48) SIGRTMIN+14	49) SIGRTMIN+15	50) SIGRTMAX-14	51) SIGRTMAX-13	52) SIGRTMAX-12
53) SIGRTMAX-11	54) SIGRTMAX-10	55) SIGRTMAX-9	56) SIGRTMAX-8	57) SIGRTMAX-7
58) SIGRTMAX-6	59) SIGRTMAX-5	60) SIGRTMAX-4	61) SIGRTMAX-3	62) SIGRTMAX-2
63) SIGRTMAX-1	64) SIGRTMAX	

Этаппы обработки сигналов:
1. Генерация сигналов. Сигнал генерируется, когда происходит одно из следующих событий
- Ядро : аппаратное прерывание, исключении/ошибка, специальном событии
- Другой процесс
- Текущий процесс самому себе
2. Доставка сигнала : сгенерированный сигнал помещается в битовую маску сигналов целевого процесса (структура, где каждый тип соответствует типу сигнала)
3. Обработка сигнала : Обработка происходит, когда процесс переходит из режима ядра в пользовательский режим (например, после завершения системного вызова или по планировщику). Ядро проверяет маску pending-сигналов(отложенных) и, если есть незаблокированные сигналы, выполняет следующие шаги:
- ядро приостанавливает нормальное выполнение процесса
- ядро сохраняет контекст прогресса (делается "снимок")
- ядро ищет обработчик сигнала (можно или написать свой или будет использован стандартный)
- ядро подготавливает пользовательский стек процесса для вызова обработчика
- ядро переключает выполнение на функцию-обработчик
- после выполнения функции-обработчика(если процесс ещё идёт), ядро восстанавливает контест процесса и начинает его с той точки, где он был прерван.

### Ответ 2 

1. Монолитные архетиктуры - вся ОС работает в одном адресном пространстве (режиме ядра). Ядро представляет собой единый, большой исполняемый модуль, где все компоненты (планировщик, файловая система, драйверы, управление памятью, сетевой стек) тесно связаны и имеют прямой доступ к данным друг друга.

+ высокая производительность (все подсистемы взаимодействуют между собой)

- ненадёжность (сбой в одном драйвере может привести к отказу всй системы)

Примеры: классические UNIX, MS-DOS.

2. Микроядерная архитектура - ядро минимально. В привилегированном режиме (ядро) работает только самый базовый функционал: управление процессами и потоками, межпроцессное взаимодействие (IPC), низкоуровневое управление памятью и прерываниями. Все остальные компоненты (драйверы устройств, файловые системы, сетевой стек) работают как изолированные пользовательские процессы (серверы).

+ Высокая надежность и стабильность — падение драйвера не крашит ядро, его можно перезапустить. Более безопасная архитектура. Легче переносить на новые платформы.

- Низкая производительность из-за постоянного переключения между режимом ядра и пользовательским режимом для IPC (хотя в современных реализациях этот недостаток смягчен).

Примеры: QNX, L4, MINIX 3, Mach (лежало в основе ранних версий macOS и NeXTSTEP).

3. Гибридное ядро - компромиссный подход. Архитектурно близко к микроядру (многие компоненты вынесены), но для повышения производительности критически важные части (например, драйверы некоторых устройств, файловая система) могут работать в пространстве ядра. По сути, это микроядро, "разросшееся" для скорости.

+ Сочетает хорошую производительность монолитных систем (для ключевых компонентов) с модульностью и относительной безопасностью микроядер.

- Сложнее чистой микроядерной архитектуры, может наследовать некоторые проблемы монолитных систем. 

Примеры: Современные Windows NT (включая 10/11), macOS X (ядро XNU = Mach + компоненты BSD). Разработчики этих ОС часто спорят о терминах, но структурно они относятся именно к гибридным.

Разница между пространством ядра и пользователя заключается доступных действиях: ядро может напрямую управлять аппаратурой и выполнять любые команды, из пространства пользователя можно только выполнять только неопасные команды, это сделано, чтобы приложения не могли навредить аппаратуре напрямую.

Основную функциональность операционных систем (ОС) можно разделить на несколько ключевых групп. Вот структурированный перечень:

1. Управление процессами

- Планирование: Распределение времени процессора между несколькими запущенными программами (процессами и потоками).
- Создание и завершение: Запуск и остановка процессов.
- Синхронизация и взаимодействие: Обеспечение механизмов для согласованной работы процессов (семафоры, мьютексы) и обмена данными между ними (каналы, очереди сообщений, общая память).
- Защита: Изоляция процессов друг от друга, предотвращение вмешательства одного процесса в память или работу другого.

2. Управление памятью (оперативной памятью - ОЗУ)

- Выделение и освобождение: Распределение памяти для процессов и её возврат в общий пул по завершении.
- Виртуальная память: Организация работы с памятью, размер которой больше физической ОЗУ, с использованием файла подкачки (swap).
- Трансляция адресов: Преобразование виртуальных адресов, которые использует программа, в физические адреса в ОЗУ (через MMU - Memory Management Unit).
- Защита памяти: Контроль доступа процессов к областям памяти, чтобы они не могли повредить память ядра ОС или других приложений.

3. Управление файловой системой и устройствами хранения

- Создание/удаление файлов и каталогов.
- Организация хранения: Иерархическая структура каталогов.
- Манипуляция файлами: Чтение, запись, перемещение, копирование, изменение атрибутов (права доступа, время создания).
- Доступ к данным: Эффективный поиск и работа с информацией на дисках (HDD, SSD).
- Квотирование и защита: Управление дисковым пространством для пользователей и контроль прав доступа к файлам.

4. Управление вводом-выводом (I/O) и устройствами

- Абстрагирование от "железа": Предоставление единого интерфейса для работы с разнородными устройствами (драйверы устройств).
- Кеширование и буферизация: Временное хранение данных для повышения скорости и эффективности обмена.
- Планирование доступа: Организация очередей запросов к устройствам (например, к жесткому диску).

5. Управление безопасностью и доступом

- Идентификация и аутентификация: Проверка личности пользователя (логин/пароль, биометрия и т.д.).
- Авторизация и контроль доступа: Определение прав пользователей и процессов на доступ к ресурсам (файлам, устройствам, памяти) — например, модель ACL (Access Control Lists) или права в Unix-системах (rwx).
- Аудит и журналирование: Протоколирование событий для последующего анализа безопасности.

6. Сетевые функции (для сетевых и распределенных ОС)

- Реализация сетевых протоколов (например, стека TCP/IP).
- Управление сетевыми ресурсами: Предоставление доступа к сетевым принтерам, файловым и web-серверам.
- Управление сетевыми соединениями: Установка, поддержка и разрыв сетевых сессий.

7. Интерфейсы взаимодействия с системой

- Интерфейс командной строки (CLI): Текстовый интерфейс для ввода команд (например, Command Prompt, Bash, PowerShell).
- Графический пользовательский интерфейс (GUI): Визуальный интерфейс с окнами, кнопками, меню (например, рабочий стол Windows, GNOME/KDE в Linux, Aqua в macOS).
- Программный интерфейс приложений (API): Набор системных вызовов (syscalls) и библиотек, через которые приложения запрашивают услуги у ядра ОС.

8. Мониторинг и учет использования ресурсов

- Сбор статистики: Отслеживание загрузки процессора, использования памяти, дискового пространства, активности сети.
- Учет использования: Ведение логов о работе системы и пользователей для анализа производительности, биллинга или отладки.

9. Поддержка отказоустойчивости и восстановления

- Обработка ошибок: Реакция на сбои оборудования и программного обеспечения.
- Средства восстановления: Возможность проверки целостности файловой системы (fsck, chkdsk), создание точек восстановления, резервное копирование.
- Избыточность данных: Поддержка RAID-массивов (на уровне ОС или драйверов).
